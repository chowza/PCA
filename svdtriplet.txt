def svdtriplet(X,roww=[],colw=[],ncp=np.inf):

	# Notes: This matches results of the R svdtriplet function pretty well except sometimes the V matrix from svd is the transpose. It's not always the case but sometimes it is.



	if roww==[]:
		roww = np.array(np.ones(X.shape[0])/X.shape[0])
	else:
		roww = np.array(roww,dtype=float)
	if colw==[]:
		colw = np.array(np.ones(X.shape[1]))
	else:
		colw = np.array(colw,dtype=float)

	ncp = min(ncp,X.shape[0]-1,X.shape[1])
	roww = roww/sum(roww)
	X = np.sqrt(colw)*X
	X = X*np.sqrt(roww[:,None])
	U = np.array([])
	s = np.array([])
	V = np.array([])

	if X.shape[1]<X.shape[0]:
		U, s, V = np.linalg.svd(X,full_matrices=False)
		V = V.T
		U = U[:,:ncp]
		V = V[:,:ncp]
		if ncp>1:
			mult = np.sign(V.sum(axis=0))
			mult[mult==0]=1
			U = mult*U
			V = mult*V
		U = U/np.sqrt(roww[:,None])
		V = V/np.sqrt(colw[:,None])
	else:
		V, s, U = np.linalg.svd(X.T,full_matrices=False)
		U = U.T
		U = U[:,:ncp]
		V = V[:,:ncp]
		mult = np.sign(V.sum(axis=0))
		mult[mult==0]=1	
		V = mult*V
		U = mult*U
		U = U/np.sqrt(roww[:,None])
		V = V/np.sqrt(colw[:,None])

	s = s[:min(X.shape[1],X.shape[0]-1)]
	num = s[:ncp] <1e-15
	if num.sum() >=1:
		U[:,num] = U[:,num]*s[num]
		V[:,num] = V[:,num]*s[num]

	return s,U,V