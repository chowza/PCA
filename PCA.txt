def PCA(X,unit=True,ncp=5,indsup=[],quantisup=[],qualisup=[],roww=[],colw=[],graph=True,axes=(1,2)):

	mx = ma.masked_array(X,mask=np.isnan(X))
	if mx.count() != X.flatten().shape:
		assert mx.count() < X.flatten().shape
		print "Warning Missing values encountered. Missing values will be replaced by the mean of the variable: you should use the imputePCA function"
		if qualisup == []:
			X = mx.filled(np.mean(mx,axis=0))
		else:
			X[:,negqualisup] = mx.filled(np.mean(mx,axis=0))[:,negqualisup]
	
	Xtot = X
	if roww == []:
		roww = np.ones(X.shape[0],dtype=float)
	else:
		roww = np.array(roww,dtype=float)
	rowwinit = roww
	roww = roww / sum(roww)

	if colw == []:
		colw = np.ones(X.shape[1],dtype=float)
	else:
		colw = np.array(colw,dtype=float)

	Xindsup = np.array([])
	Xquantisup = np.array([])
	Xqualisup = np.array([])

	if qualisup !=[] and quantisup !=[]:
		Xquantisup = X[:,quantisup]
		Xqualisup = X[:,qualisup]
		X = np.delete(Xtot,qualisup+quantisup,1)
		colw = np.delete(colw,qualisup+quantisup)
	elif qualisup != [] and quantisup == []:
		Xqualisup = X[:,qualisup]
		X = np.delete(Xtot,qualisup,1)
		colw = np.delete(colw,qualisup)
	elif quantisup !=[] and qualisup ==[]:
		Xquantisup = X[:,quantisup]
		X = np.delete(Xtot,quantisup,1)
		colw = np.delete(colw,quantisup)

	if indsup != []:
		Xindsup = X[indsup]
		X = np.delete(X,indsup,0)
		roww = np.delete(roww,indsup,0)
		Xquantisup = np.delete(Xquantisup,indsup,0)
		Xqualisup = np.delete(Xqualisup,indsup,0)

	ncp = min(ncp,X.shape[0]-1,X.shape[1])

	centre = np.dot(roww,X)/sum(roww)
	data = X
	X = X-centre
	if unit:
		distancetype = np.sqrt(np.dot(roww,X**2)/sum(roww))
		lessthan = distancetype<=1e-16
		distancetype[lessthan] = 1
		X = X/distancetype
	else:
		distancetype = np.ones(centre.shape)

	dist2ind = ((np.sqrt(colw)*X)**2).sum(axis=1)
	dist2var = ((X*np.sqrt(roww[:,None]))**2).sum(axis=0)
	eig,U,V = svdtriplet(X,roww=roww,colw=colw,ncp=ncp)
	eig = eig**2
	percentvar = eig/sum(eig)

	eig = eig[:ncp]
	coordind = np.sqrt(eig)*U
	coordvar = np.sqrt(eig)*V
	contribvar = coordvar**2/eig
	contribvar = contribvar*colw[:,None]
	dist2 = dist2var
	corvar = coordvar/np.sqrt(dist2)[:,None]
	cos2var = corvar**2
# At this point, the rows of coordvar,cos2var,corvar and contribvar represent the feature variables while the columns represent the points in that dimension. I.e if there are only 2 columns, those feature variables have now been mapped into 2 dimensional space

	dist2 = dist2ind
	cos2ind = coordind**2/dist2[:,None]
	contribind = coordind**2*roww[:,None]/sum(roww)
	contribind = contribind/eig
	
	if indsup !=[]:
		assert distancetype is not None
		Xindsup = Xindsup-centre
		Xindsup = Xindsup/distancetype
		coordindsup = Xindsup*colw
		coordindsup = np.dot(coordindsup,V)
		dist2 = ((np.sqrt(colw)*Xindsup)**2).sum(axis=1)
		cos2indsup = coordindsup**2/dist2[:,None]
		coordindsup = coordindsup[:,:ncp]
		cos2indsup = cos2indsup[:,:ncp]
	
	if quantisup !=[]:
		centresup = np.dot(roww,Xquantisup)/sum(roww)
		Xquantisup = Xquantisup - centresup
		if unit:
			distancetypesup = np.sqrt(np.dot(roww,Xquantisup**2)/sum(roww))
			lessthansup = distancetypesup<=1e-16
			distancetypesup[lessthansup] = 1
			Xquantisup = Xquantisup/distancetypesup
		coordvcs = Xquantisup.T*roww
		coordvcs = np.dot(coordvcs,U)
		colwvcs = np.ones(coordvcs.shape[1])
		sigma = np.sqrt(np.dot(roww,Xquantisup**2)/sum(roww))
		dist2 = ((Xquantisup*np.sqrt(roww[:,None]))**2).sum(axis=0)
		corvcs = coordvcs/np.sqrt(dist2[:,None])
		cos2vcs = corvcs**2

	qualisuprsquared=[]
	if qualisup !=[]:
		for i in range(0,ncp):
			wlmfit=np.polynomial.polynomial.polyfit(coordind[:,i].flatten(),Xqualisup.flatten(),1,w=np.sqrt(roww),full=True)
			poly = np.poly1d(wlmfit[0][::-1])
			fitted = poly(coordind[:,i])
			m = sum(roww*fitted/sum(roww))
			mss = sum(roww*(fitted-m)**2)
			qualisuprsquared.append(mss/(mss+wlmfit[1][0])[0])
		for i in range(0,Xqualisup.shape[1]):
			var = 